#!/usr/bin/env ruby

require 'rubygems'
require 'singleton'
require 'fssm'
require 'yaml'

class Match
  attr_accessor :filename

  def initialize(glob, &block)
    @glob = escape_glob(glob)
    @block = block
  end

  # Causes a reload of the worker scripts
  def reload!
    say "RELOADING!"
    Foreman.instance.reload!
  end
  
  # Forward on the msg to the foreman
  def say(msg)
    Foreman.instance.say(msg)
  end
  
  # TODO wrap this in some sort of popen3 call 
  def run(cmd)
    say `#{cmd}`
  end

  def start(path, file)
    @filename = File.join(path, file)
    
    if @glob =~ filename
      @source = filename
      instance_exec(filename, &@block) 
    end
  end

  def like(name)
    dir = File.dirname(name)
    @source = Dir.glob(File.join(dir, File.basename(name, '.*') + '.*'))
  end

  def copy(*args)
    if(args.count == 1) 
      @destination = args.first
    elsif args.count > 1
      @destination = args.pop
      @source = args.flatten
    end

    if @source && @destination
      say "Copying #{@source.inspect} to #{@destination}"
      FileUtils.mkdir_p(@destination)
      FileUtils.cp_r(@source, @destination)
    end
  end

  def source(name=[])
    @source = name
    @destination
  end
  alias_method :from, :source

  def destination(name)
    raise "Could not find #{name}" unless File.exists?(name)
    @destination = name
  end
  alias_method :to, :destination

  def filename(args = nil)
    @filename
  end
  
  protected
  
  def escape_glob(glob)
    if glob.class == String 
      Regexp.new(Regexp.escape(glob))
    else 
      glob
    end
  end  
end

# Does not persist, do not use any class variables 
class Watch
  include Singleton

  def match(glob, &block) 
    Match.new(glob, &block)
  end
  
  def extension(glob)
    Regexp.new("\.#{glob}$")
  end
  
  def method_missing(method, value = nil)
    return method.to_s
  end
  
  def say(msg)
    Foreman.instance.say(msg)
  end
end

# Handle the incoming watch requests and assign the workers
class Conveyor
  include Singleton
  
  def initialize
    @config = read_configs
    @worker_defs = ARGV.shift
    @worker_defs ||= @config["worker_defs"]
  end
  
  def read_configs
    if File.exists?('.foreman')
      YAML.load(File.open('.foreman'))
    elsif File.exists?('~/.foreman')
      YAML.load(File.open('~/.foreman'))
    else
      { "worker_defs" => File.expand_path('../workers/', File.dirname(__FILE__)) }
    end
  end
  
  def say(msg)
    puts(msg)
    # this should pass it on to the logger
  end
  
  def log(msg)
    # Do the work of passing it on to some logger object handler
  end

  def watch(name, &block)
    name = File.expand_path(name)
    
    raise "Directory #{name} not found" unless File.directory? name
    if @directories.include? name
      say '**************************'
      say "Already watching #{name}!!"
      say 'Ignoring second watch'
      say '**************************'
      return
    else
      say "Watching #{name}"
    end

    @directories[name] ||= []
    @current = @directories[name]

    @current << Watch.instance.instance_eval(&block)
  end

  def monitor
    reload!

    say "Starting Monitor"
    @fssm = FSSM::Monitor.new

    @directories.keys.each do |dir|
      @fssm.path(dir) do
        update do |path,filename| 
          Foreman.instance.dispath(path, filename)  
        end
        create do |path,filename| 
          Foreman.instance.dispath(path, filename)  
        end

      end
    end
    
    say "Started Monitor"
    @running = true
    @fssm.run
  end

  def dispath(path, filename)
    @directories[path].each do |worker|
      worker.start(path, filename)
    end
  end

  def reload!
    say "Loading workers from #{@worker_defs}"
    @directories = {}
    Dir.glob(File.join(@worker_defs, '*.worker')) do |file|
      load file
    end
  end
end

def watch(name, &block)
  Foreman.instance.watch(name, &block)
end

Conveyor.instance.monitor
